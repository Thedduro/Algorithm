#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 2493                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: lsw2207 <boj.kr/u/lsw2207>                  +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/2493                           #+#        #+#      #+#     #
#    Solved: 2025/09/10 16:42:47 by lsw2207       ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #

"""
    - 문제:
        - 자신의 위치에서 자신보다 크고 가장 가까운 큰 숫자의 인덱스를 찾아라
        - N = 500,000 > N 만큼의 연산만 사용해야 함
    - IDEA:
        - 배열의 앞부터 순차적으로 스택에 삽입
            - 스택이 비어있으면? > 막고있는 탑이 없음
            - 앞과 스택을 비교 했을때, 나보다 큰 값이 없다...?
                - 모든 스택을 초기화 하고 스택에 넣는다
            - 나보다 커, > 삽입 > 앞의 원소의 인덱스 값을 기록
"""
N = int(input())

arr = list(map(int, input().split()))
stack = []
result = [0] * N

IDX = 1

while IDX <= N:
    v = arr[IDX-1] # 현재 값

    while stack and stack[-1][0] < v: # 나보다 작아? 
        stack.pop()

    if stack: # 스택이 비어 있지 않다면 → 현재 탑보다 큰 탑이 수신
        result[IDX-1] = stack[-1][1]
        stack.append((v,IDX))

    else: # 스택이 비었음 > 나보다 큰 탑이 없음
        result[IDX-1] = 0
        stack.append((v,IDX)) # 스택에 삽입

    IDX += 1

print(*result)