# 비트마스킹(Bitmasking) 개념 완전 정리

비트마스킹은 여러 개의 ON/OFF 상태를 하나의 정수로 표현하는 기법이다.  
각 상태를 비트(0 또는 1)로 나타내고, 비트 연산을 활용해 빠르게 조합 및 체크를 수행할 수 있다.

------------------------------------------------------------

## 1. 비트와 이진수 기본 개념

- 비트(bit) : 컴퓨터에서 0 또는 1 한 칸
- 정수는 내부적으로 이진수로 저장됨
  예: 5 → 101, 13 → 1101

------------------------------------------------------------

## 2. 비트마스킹이란?

"여러 개의 요소가 존재하는지 여부"를 하나의 정수로 표현하는 기술.

예를 들어 숫자 0, 3, 5가 존재한다면:

0001001001  (이진)

- 0번째 비트 : 1 (0 존재)
- 3번째 비트 : 1 (3 존재)
- 5번째 비트 : 1 (5 존재)

이 하나의 정수(mask)로 집합을 표현할 수 있다.

------------------------------------------------------------

## 3. 비트 한 칸 만들기: (1 << x)

(1 << x)는 "x번째 비트만 1인 값"을 만든다.

1 << 0 → 0000000001  
1 << 3 → 0000001000  
1 << 5 → 0001000000  

즉 x라는 숫자가 있다는 표시 비트이다.

------------------------------------------------------------

## 4. 비트마스크에 숫자 추가: mask |= (1 << x)

mask |= (1 << x)는  
mask = mask | (1 << x) 와 같으며

mask에 x번째 비트를 추가(켜기)한다는 의미이다.

집합으로 치면  
set.add(x) 와 동일한 역할.

------------------------------------------------------------

## 5. 비트마스크 주요 연산

1) 원소 추가
mask |= (1 << x)

2) 원소 존재 확인
if mask & (1 << x): 존재함

3) 두 집합 합치기
new_mask = mask | other_mask

비트 OR는 집합의 합집합과 동일한 역할을 한다.

------------------------------------------------------------

## 6. 0~9 전체 숫자가 있는 상태 만들기

0~9 모두 있는 비트 상태는 10개의 비트가 모두 1인 값:

1111111111   (2진수)

십진수로는 1023이다.

이를 만드는 가장 표준적인 공식:

TARGET = (1 << 10) - 1

(1 << 10) = 10000000000  
여기서 1을 빼면 1111111111 이 된다.

즉 TARGET은 0~9 모든 숫자가 존재하는 상태를 뜻한다.

------------------------------------------------------------

## 7. 문제 적용: 퍼즐 세트 최소 선택 문제

여러 퍼즐 세트가 있고, 각 세트는 0~9 중 여러 숫자를 포함한다.  
목표는 “0~9를 모두 포함하도록 최소 세트만 선택하기”.

비트마스크 사용법:
1) 각 세트를 비트마스크로 변환
2) OR 연산으로 세트를 합침
3) TARGET(0~9 모두 1) 상태에 도달하는 최소 횟수 탐색

이 문제에는 BFS가 최적이다.
BFS는 적은 세트 수부터 탐색하므로 최초 도달이 곧 최소 세트 개수이다.

------------------------------------------------------------

## 8. 세트를 비트마스크로 변환하는 코드 (설명용, README에 포함)

masks = []
for puzzle in puzzles:
    mask = 0
    for x in puzzle:
        mask |= (1 << x)
    masks.append(mask)

각 mask는 한 세트가 포함하는 숫자들을 비트로 표현한 정수이다.

------------------------------------------------------------

## 9. BFS를 이용한 최소 세트 개수 찾기 코드 (설명용)

from collections import deque

N, M = map(int, input().split())
puzzles = [list(map(int, input().split())) for _ in range(N)]

masks = []
for puzzle in puzzles:
    mask = 0
    for x in puzzle:
        mask |= (1 << x)
    masks.append(mask)

TARGET = (1 << 10) - 1

q = deque()
visited = [False] * (1 << 10)

q.append((0, 0))  # (현재 비트마스크, 사용 세트 수)
visited[0] = True

while q:
    mask, cnt = q.popleft()

    if mask == TARGET:
        print(cnt)
        break

    for m in masks:
        new_mask = mask | m
        if not visited[new_mask]:
            visited[new_mask] = True
            q.append((new_mask, cnt + 1))

------------------------------------------------------------

## 10. 비트를 2진수 형태로 보고 싶다면

print(bin(mask))

예)
41 → 0b101001  
= {0, 3, 5} 존재

------------------------------------------------------------

## 11. 요약

- 비트마스크 = 여러 개의 ON/OFF 상태를 정수 하나로 표현하는 방법
- (1 << x) = x번째 비트만 1
- mask |= (1 << x) = mask에 x 추가
- (1 << 10) - 1 = 0~9 모두 포함한 상태
- BFS/DP와 결합하면 최소 세트 선택 문제를 빠르게 해결 가능

비트마스킹은 조합, 부분집합, 최단 선택 등의 문제에서 매우 강력하다.
